       |import std.stdio : write, writef, writeln, writefln;
       |import std.string : strip;
       |
       |/// Version
       |const string ver = "0.2.1";
       |
       |version(DLL)
       |{
       |import core.sys.windows.windows, core.sys.windows.dll;
       |/// Handle instance
       |__gshared HINSTANCE g_hInst;
       | 
       |/// DLL Entry point
       |version(Windows) extern(Windows) bool DllMain(void* hInstance, uint ulReason, void*)
       |{
       |    switch (ulReason)
       |    {
       |        default: assert(0);
       |        case DLL_PROCESS_ATTACH:
       |            dll_process_attach(hInstance, true);
       |            break;
       |
       |        case DLL_PROCESS_DETACH:
       |            dll_process_detach(hInstance, true);
       |            break;
       |
       |        case DLL_THREAD_ATTACH:
       |            dll_thread_attach(true, true);
       |            break;
       |
       |        case DLL_THREAD_DETACH:
       |            dll_thread_detach(true, true);
       |            break;
       |    }
       |    return true;
       |}
       |
       |// Trash
       |/// Gets the class object for this DLL
       |version(Windows) extern(Windows) void DllGetClassObject() {}
       |/// Returns if the DLL can unload now
       |version(Windows) extern(Windows) void DllCanUnloadNow() {}
       |/// Registers with the COM server
       |version(Windows) extern(Windows) void DllRegisterServer() {}
       |/// Unregisters with the COM server
       |version(Windows) extern(Windows) void DllUnregisterServer() {}
       |} else {
       |void main(string[] args)
       |{
      1|    bool _dbg = false; // Debug
      1|    bool _det = false; // Detailed output
      1|    bool _oml = false; // Override max leaf
       |
      9|    foreach (s; args)
       |    {
      2|        switch (s)
       |        {
0000000|        case "/?":
0000000|        case "-h":
0000000|        case "--help":
0000000|            writeln(" ddcpuid [<Options>]");
0000000|            writeln();
0000000|            writeln(" --details, -D    Gets more details.");
0000000|            writeln(" --override, -O   Overrides leafs to 0x20 and 0x8000_0020");
0000000|            writeln(" --debug          Gets debugging information.");
0000000|            writeln();
0000000|            writeln(" --help      Prints help and quit.");
0000000|            writeln(" --version   Prints version and quit.");
0000000|            return;
       | 
0000000|        case "-v":
0000000|        case "--version":
0000000|            writeln("ddcpuid ", ver);
0000000|            writeln("Copyright (c) guitarxhero 2016");
0000000|            writeln("License: MIT License <http://opensource.org/licenses/MIT>");
0000000|            writeln("Project page: <https://github.com/guitarxhero/ddcpuid>");
0000000|            writefln("Compiled %s at %s, using %s version %s.",
       |                __FILE__, __TIMESTAMP__, __VENDOR__, __VERSION__);
0000000|            return;
       |
      1|        case "-D":
      1|        case "--details":
      1|            _det = true;
      1|            break;
       |
0000000|        case "-O":
0000000|        case "--override":
0000000|            _oml = true;
0000000|            break;
       |
0000000|        case "--debug":
0000000|            _dbg = true;
0000000|            break;
       |
      1|        default:
       |        }
       |    }
       |
       |    // Maximum leaf
      2|    int max = _oml ? 0x20 : getHighestLeaf();
       |    // Maximum extended leaf
      2|    int emax = _oml ? 0x8000_0020 : getHighestExtendedLeaf();
       |
      1|    if (_dbg)
       |    {
0000000|        writeln("|   Leaf   | Sub-leaf | EAX      | EBX      | ECX      | EDX      |");
0000000|        writeln("|----------|----------|----------|----------|----------|----------| ");
0000000|        uint _eax, _ebx, _ecx, _edx, _ebp, _esp, _edi, _esi;
0000000|        for (int leaf = 0; leaf <= max; ++leaf)
       |        {
       |            asm
       |            {
       |                mov EAX, leaf;
       |                cpuid;
       |                mov _eax, EAX;
       |                mov _ebx, EBX;
       |                mov _ecx, ECX;
       |                mov _edx, EDX;
       |            }
0000000|            writefln("| %8X |        0 | %8X | %8X | %8X | %8X |",
       |                leaf, _eax, _ebx, _ecx, _edx);
       |        }
0000000|        for (int eleaf = 0x8000_0000; eleaf <= emax; ++eleaf)
       |        {
       |            asm
       |            {
       |                mov EAX, eleaf;
       |                cpuid;
       |                mov _eax, EAX;
       |                mov _ebx, EBX;
       |                mov _ecx, ECX;
       |                mov _edx, EDX;
       |            }
0000000|            writefln("| %8X |        0 | %8X | %8X | %8X | %8X |",
       |                eleaf, _eax, _ebx, _ecx, _edx);
       |        }
       |        asm
       |        {
       |            mov _ebp, EBP;
       |            mov _esp, ESP;
       |            mov _edi, EDI;
       |            mov _esi, ESI;
       |        }
0000000|        writefln("EBP=%-8X ESP=%-8X EDI=%-8X ESI=%-8X", _ebp, _esp, _edi, _esi);
0000000|        writeln();
       |    }
       |    else
       |    {
      1|        const CPU_INFO cpuinfo = new CPU_INFO();
      1|        with (cpuinfo)
       |        {
      1|            writeln("Vendor: ", Vendor);
      1|            writeln("Model: ", ProcessorBrandString);
      1|            writefln("Identification: Family %X [%X:%X] Model %X [%X:%X] Stepping %X",
       |                Family, BaseFamily, ExtendedFamily,
       |                Model, BaseModel, ExtendedModel,
       |                Stepping);
       |
      1|            write("Extensions: ");
      1|            if (MMX)
      1|                write("MMX, ");
      1|            if (SSE)
      1|                write("SSE, ");
      1|            if (SSE2)
      1|                write("SSE2, ");
      1|            if (SSE3)
      1|                write("SSE3, ");
      1|            if (SSSE3)
      1|                write("SSSE3, ");
      1|            if (SSE41)
      1|                write("SSE4.1, ");
      1|            if (SSE42)
      1|                write("SSE4.2, ");
      1|            if (SSE4a)
0000000|                write("SSE4a, ");
      1|            if (LongMode)
      1|                switch (Vendor)
       |                {
      3|                    case "GenuineIntel": write("Intel64, "); break;
0000000|                    case "AuthenticAMD": write("AMD64, ");   break;
0000000|                    default:
       |                }
      1|            if (VMX)
      1|                switch (Vendor)
       |                {
      3|                    case "GenuineIntel": write("VT-x, ");  break; // VMX
0000000|                    case "AuthenticAMD": write("AMD-V, "); break; // SVM
0000000|                    default:
       |                }
      1|            if (AESNI)
      1|                write("AES-NI, ");
      1|            if (AVX)
      1|                write("AVX, ");
      1|            if (AVX2)
0000000|                write("AVX2, ");
      1|            if (SMX)
      1|                write("SMX, ");
      1|            if (DS_CPL)
      1|                write("DS-CPL, ");
      1|            if (FMA) 
0000000|                write("FMA, ");
      1|            if (F16C)
      1|                write("F16C, ");
      1|            if (XSAVE)
      1|                write("XSAVE, ");
      1|            if (OSXSAVE)
      1|                write("OSXSAVE, ");
      1|            writeln();
       |
      1|            writeln("Hyper-Threading Technology: ", HTT);
      1|            writeln("Turbo Boost Available: ", TurboBoost);
      1|            writeln("Enhanced Intel SpeedStep technology: ", EIST);
       |
      1|            if (_det)
       |            {
      1|                write("Single instructions: [ ");
      1|                if (MONITOR)
      1|                    write("MONITOR/MWAIT, ");
      1|                if (PCLMULQDQ)
      1|                    write("PCLMULQDQ, ");
      1|                if (CX8)
      1|                    write("CMPXCHG8B, ");
      1|                if (CMPXCHG16B)
      1|                    write("CMPXCHG16B, ");
      1|                if (MOVBE)
0000000|                    write("MOVBE, "); // Intel Atom only!, and quite a few AMDs.
      1|                if (RDRAND)
      1|                    write("RDRAND, ");
      1|                if (MSR)
      1|                    write("RDMSR/WRMSR, ");
      1|                if (SEP)
      1|                    write("SYSENTER/SYSEXIT, ");
      1|                if (TSC)
       |                {
      1|                    write("RDTSC");
      1|                    if (TSC_Deadline || TscInvariant)
       |                    {
      1|                        write(" (");
      1|                        if (TSC_Deadline)
      1|                            write("TSC-Deadline");
      1|                        if (TscInvariant)
      1|                            write(", TSC-Invariant");
      1|                        write(")");
       |                    }
      1|                    write(", ");
       |                }
      1|                if (CMOV)
      1|                    write("CMOV, ");
      2|                if (FPU && CMOV)
      1|                    write("FCOMI/FCMOV, ");
      1|                if (CLFSH)
      1|                    writef("CLFLUSH (Lines: %s), ", CLFLUSHLineSize);
      1|                if (POPCNT)
      1|                    write("POPCNT, ");
      1|                if (FXSR)
      1|                    write("FXSAVE/FXRSTOR, ");
      1|                writeln("]");
       |
      1|                writeln();
      1|                writeln(" Memory handling");
      1|                writeln(" ================");
      1|                writeln();
       |
      1|                writeln();
      1|                writeln(" Floating Point");
      1|                writeln(" ================");
      1|                writeln();
      1|                writeln("Floating Point Unit [FPU]: ", FPU);
       |
      1|                writeln();
      1|                writeln(" Virtualization");
      1|                writeln(" ================");
      1|                writeln();
       |
      1|                writeln();
      1|                writeln(" Details");
      1|                writeln(" ================");
      1|                writeln();
      1|                writefln("Highest Leaf: %02XH | Extended: %02XH", max, emax);
      1|                write("Processor type: ");
      1|                final switch (ProcessorType) // 2 bit value
       |                { // Only Intel uses this, AMD will always return 0.
      1|                    case 0:
      1|                        writeln("Original OEM Processor");
      1|                        break;
0000000|                    case 1:
0000000|                        writeln("Intel OverDrive Processor");
0000000|                        break;
0000000|                    case 2:
0000000|                        writeln("Dual processor");
0000000|                        break;
0000000|                    case 3:
0000000|                        writeln("Intel reserved");
0000000|                        break;
       |                }
       |
      1|                writeln("Brand Index: ", BrandIndex);
       |                // MaximumNumberOfAddressableIDs / 2 (if HTT) for # cores?
      1|                writeln("Max # of addressable IDs: ", MaximumNumberOfAddressableIDs);
      1|                writefln("APIC: %s (Initial ID: %s)", APIC, InitialAPICID);
      1|                writeln("x2APIC: ", x2APIC);
      1|                writeln("64-bit DS Area [DTES64]: ", DTES64);
      1|                writeln("Thermal Monitor [TM]: ", TM);
      1|                writeln("Thermal Monitor 2 [TM2]: ", TM2);
      1|                writeln("L1 Context ID [CNXT-ID]: ", CNXT_ID);
      1|                writeln("xTPR Update Control [xTPR]: ", xTPR);
      1|                writeln("Perfmon and Debug Capability [PDCM]: ", PDCM);
      1|                writeln("Process-context identifiers [PCID]: ", PCID);
      1|                writeln("Direct Cache Access [DCA]: ", DCA);
      1|                writeln("Virtual 8086 Mode Enhancements [VME]: ", VME);
      1|                writeln("Debugging Extensions [DE]: ", DE);
      1|                writeln("Page Size Extension [PAE]: ", PAE);
      1|                writeln("Machine Check Exception [MCE]: ", MCE);
      1|                writeln("Memory Type Range Registers [MTRR]: ", MTRR);
      1|                writeln("Page Global Bit [PGE]: ", PGE);
      1|                writeln("Machine Check Architecture [MCA]: ", MCA);
      1|                writeln("Page Attribute Table [PAT]: ", PAT);
      1|                writeln("36-Bit Page Size Extension [PSE-36]: ", PSE_36);
      1|                writeln("Processor Serial Number [PSN]: ", PSN);
      1|                writeln("Debug Store [DS]: ", DS);
      1|                writeln("Thermal Monitor and Software Controlled Clock Facilities [APCI]: ", APCI);
      1|                writeln("Self Snoop [SS]: ", SS);
      1|                writeln("Pending Break Enable [PBE]: ", PBE);
      1|                writeln("Supervisor Mode Execution Protection [SMEP]: ", SMEP);
      1|                write("Bit manipulation groups: ");
      2|                if (BMI1 || BMI2)
       |                {
0000000|                    if (BMI1)
0000000|                        write("BMI1, ");
0000000|                    if (BMI2)
0000000|                        write("BMI2");
       |                }
       |                else
      1|                    writeln("None");
       |            } // if (_det)
       |        } // with (c)
       |    } // else if
       |} // main
       |
       |/// <summary>
       |/// Gets the highest leaf possible for this processor.
       |/// </summay>
       |public int getHighestLeaf()
       |{
       |    asm
       |    {
       |        naked;
       |        mov EAX, 0;
       |        cpuid;
       |        ret;
       |    }
       |}
       |
       |/// <summary>
       |/// Get the Processor Brand string
       |/// </summary>
       |public int getHighestExtendedLeaf()
       |{
       |    asm
       |    {
       |        naked;
       |        mov EAX, 0x80000000;
       |        cpuid;
       |        ret;
       |    }
       |}
       |
       |/// <summary>
       |/// Gets the CPU Vendor string.
       |/// </summay>
       |public string getVendor()
       |{
      1|    string s;
      3|    int ebx, edx, ecx;
      1|    char* p = cast(char*)&ebx;
       |    asm
       |    {
       |        mov EAX, 0;
       |        cpuid;
       |        mov ebx, EBX;
       |        mov ecx, ECX;
       |        mov edx, EDX;
       |    }
      1|    s ~= *p;
      1|    s ~= *(p + 1);
      1|    s ~= *(p + 2);
      1|    s ~= *(p + 3);
      1|    s ~= *(p + 4);
      1|    s ~= *(p + 5);
      1|    s ~= *(p + 6);
      1|    s ~= *(p + 7);
      1|    s ~= *(p + 8);
      1|    s ~= *(p + 9);
      1|    s ~= *(p + 10);
      1|    s ~= *(p + 11);
      1|    return s;
       |}
       |
       |/// <summary>
       |/// Get the Processor Brand string
       |/// </summary>
       |public string getProcessorBrandString()
       |{
      1|    string s;
      4|    int eax, ebx, ecx, edx;
      1|    char* p = cast(char*)&eax;
      8|    for (int i = 0x80000002; i <= 0x80000004; ++i)
       |    {
       |        asm
       |        {
       |            mov EAX, i;
       |            cpuid;
       |            mov eax, EAX;
       |            mov ebx, EBX;
       |            mov ecx, ECX;
       |            mov edx, EDX;
       |        }
      3|        s ~= *p;
      3|        s ~= *(p + 1);
      3|        s ~= *(p + 2);
      3|        s ~= *(p + 3);
      3|        s ~= *(p + 4);
      3|        s ~= *(p + 5);
      3|        s ~= *(p + 6);
      3|        s ~= *(p + 7);
      3|        s ~= *(p + 8);
      3|        s ~= *(p + 9);
      3|        s ~= *(p + 10);
      3|        s ~= *(p + 11);
      3|        s ~= *(p + 12);
      3|        s ~= *(p + 13);
      3|        s ~= *(p + 14);
      3|        s ~= *(p + 15);
       |    }
      1|    return s;
       |}
       |
       |/***********
       | * Classes *
       | ***********/
       |
       |/// <summary>
       |/// Provides a set of information about the processor.
       |/// </summary>
       |public class CPU_INFO
       |{
       |    /// Initiates a CPU_INFO.
      1|    this(bool fetch = true)
       |    {
      1|        if (fetch)
      1|            fetchInfo();
       |    }
       |
       |    /// Fetches the information 
       |    public void fetchInfo()
       |    {
      1|        Vendor = getVendor();
      1|        ProcessorBrandString = strip(getProcessorBrandString());
       |
      1|        MaximumLeaf = getHighestLeaf();
      1|        MaximumExtendedLeaf = getHighestExtendedLeaf();
       |
      4|        int a, b, c, d;
     28|        for (int leaf = 1; leaf <= MaximumLeaf; ++leaf)
       |        {
       |            asm
       |            {
       |                mov EAX, leaf;
       |                cpuid;
       |                mov a, EAX;
       |                mov b, EBX;
       |                mov c, ECX;
       |                mov d, EDX;
       |            }
       |
     13|            switch (leaf)
       |            { // case 0 has already has been handled (max leaf and vendor).
      1|                case 1: // 01H -- Basic CPUID Information
       |                    // EAX
      1|                    BaseFamily     = a >>  8 &  0xF; // EAX[11:8]
      1|                    ExtendedFamily = a >> 20 & 0xFF; // EAX[27:20]
      1|                    BaseModel      = a >>  4 &  0xF; // EAX[7:4]
      1|                    ExtendedModel  = a >> 16 &  0xF; // EAX[19:16]
      1|                    switch (Vendor)
       |                    {
      1|                        case "GenuineIntel": // Intel only section
      1|                            if (BaseFamily != 0)
      1|                                Family = BaseFamily;
       |                            else
0000000|                                Family = cast(ubyte)(ExtendedFamily + BaseFamily);
       |
      1|                            if (BaseFamily == 6 || BaseFamily == 0)
      1|                                Model = cast(ubyte)((ExtendedModel << 4) + BaseModel);
       |                            else // DisplayModel = Model_ID;
0000000|                                Model = BaseModel;
       |
       |                            // ECX
      1|                            DTES64  = c >>  2 & 1;
      1|                            DS_CPL  = c >>  4 & 1;
      1|                            VMX     = c >>  5 & 1;
      1|                            SMX     = c >>  6 & 1;
      1|                            EIST    = c >>  7 & 1;
      1|                            CNXT_ID = c >> 10 & 1;
      1|                            SDBG    = c >> 11 & 1;
      1|                            xTPR    = c >> 14 & 1;
      1|                            PDCM    = c >> 15 & 1;
      1|                            PCID    = c >> 17 & 1;
      1|                            DCA     = c >> 18 & 1;
       |
      1|                            DS      = d >> 21 & 1;
      1|                            APCI    = d >> 22 & 1;
      1|                            SS      = d >> 27 & 1;
      1|                            TM      = d >> 29 & 1;
      1|                            PBE     = d >> 31 & 1;
      1|                            break;
       |
0000000|                        case "AuthenticAMD": // AMD only section
0000000|                            if (BaseFamily < 0xF)
0000000|                                Family = BaseFamily;
       |                            else
0000000|                                Family = cast(ubyte)(ExtendedFamily + BaseFamily);
       |
0000000|                            if (BaseFamily < 0xF)
0000000|                                Model = BaseModel;
       |                            else
0000000|                                Model = cast(ubyte)((ExtendedModel << 4) + BaseModel);
0000000|                            break;
       |
0000000|                            default:
       |                    }
       |
      1|                    ProcessorType = (a >> 12) & 3; // EAX[13:12]
      1|                    Stepping = a & 0xF; // EAX[3:0]
       |                    // EBX
      1|                    BrandIndex = b & 0xFF; // EBX[7:0]
      1|                    CLFLUSHLineSize = b >> 8 & 0xFF; // EBX[15:8]
      1|                    MaximumNumberOfAddressableIDs = b >> 16 & 0xFF; // EBX[23:16]
      1|                    InitialAPICID = b >> 24 & 0xFF; // EBX[31:24]
       |                    // ECX
      1|                    SSE3         = c & 1;
      1|                    PCLMULQDQ    = c >>  1 & 1;
      1|                    MONITOR      = c >>  3 & 1;
      1|                    TM2          = c >>  8 & 1;
      1|                    SSSE3        = c >>  9 & 1;
      1|                    FMA          = c >> 12 & 1;
      1|                    CMPXCHG16B   = c >> 13 & 1;
      1|                    SSE41        = c >> 19 & 1;
      1|                    SSE42        = c >> 20 & 1;
      1|                    x2APIC       = c >> 21 & 1;
      1|                    MOVBE        = c >> 22 & 1;
      1|                    POPCNT       = c >> 23 & 1;
      1|                    TSC_Deadline = c >> 24 & 1;
      1|                    AESNI        = c >> 25 & 1;
      1|                    XSAVE        = c >> 26 & 1;
      1|                    OSXSAVE      = c >> 27 & 1;
      1|                    AVX          = c >> 28 & 1;
      1|                    F16C         = c >> 29 & 1;
      1|                    RDRAND       = c >> 30 & 1;
       |                    // EDX
      1|                    FPU    = d & 1;
      1|                    VME    = d >>  1 & 1;
      1|                    DE     = d >>  2 & 1;
      1|                    PSE    = d >>  3 & 1;
      1|                    TSC    = d >>  4 & 1;
      1|                    MSR    = d >>  5 & 1;
      1|                    PAE    = d >>  6 & 1;
      1|                    MCE    = d >>  7 & 1;
      1|                    CX8    = d >>  8 & 1;
      1|                    APIC   = d >>  9 & 1;
      1|                    SEP    = d >> 11 & 1;
      1|                    MTRR   = d >> 12 & 1;
      1|                    PGE    = d >> 13 & 1;
      1|                    MCA    = d >> 14 & 1;
      1|                    CMOV   = d >> 15 & 1;
      1|                    PAT    = d >> 16 & 1;
      1|                    PSE_36 = d >> 17 & 1;
      1|                    PSN    = d >> 18 & 1;
      1|                    CLFSH  = d >> 19 & 1;
      1|                    MMX    = d >> 23 & 1;
      1|                    FXSR   = d >> 24 & 1;
      1|                    SSE    = d >> 25 & 1;
      1|                    SSE2   = d >> 26 & 1;
      1|                    HTT    = d >> 28 & 1;
      1|                    break;
       |
      1|                case 2: // 02h -- Cache and TLB Information. | AMD: Reserved
       |
      1|                    break;
       |
      1|                case 6: // 06h -- Thermal and Power Management Leaf | AMD: Reversed
      1|                    switch (Vendor)
       |                    {
      1|                        case "GenuineIntel":
      1|                            TurboBoost = a >> 1 & 1;
      1|                            break;
       |
0000000|                        default:
       |                    }
      1|                    break;
       |
      9|                    default:
       |
     10|                case 7:
     10|                    BMI1 = b >> 3 & 1;
     10|                    AVX2 = b >> 5 & 1;
     10|                    SMEP = b >> 7 & 1;
     10|                    BMI2 = b >> 8 & 1;
     10|                    break;
       |            }
       |        }
       |
       |        /*******************
       |         * Extended leaves *
       |         *******************/
       |
     18|        for (int eleaf = 0x8000_0000; eleaf < MaximumExtendedLeaf; ++eleaf)
       |        {
       |            asm
       |            {
       |                mov EAX, eleaf;
       |                cpuid;
       |                mov a, EAX;
       |                mov b, EBX;
       |                mov c, ECX;
       |                mov d, EDX;
       |            }
       |
      8|            switch (eleaf)
       |            {
      1|                case 0x8000_0000:
       |                
      1|                break;
       |
      1|                case 0x8000_0001:
      1|                    switch (Vendor)
       |                    {
0000000|                        case "AuthenticAMD":
0000000|                            VMX = c >> 2 & 1; // SVM
0000000|                            SSE4a = c >> 6 & 1;
0000000|                            break;
       |
      1|                        default:
       |                    }
       |
      1|                    LongMode = d >> 29 & 1;
       |
      1|                    break;
       |
      1|                case 0x8000_0007:
      1|                    switch (Vendor)
       |                    {
0000000|                        case "AuthenticAMD":
0000000|                            TM = d >> 4 & 1;
0000000|                            break;
       |
      1|                        default:
       |                    }
       |
      1|                    TscInvariant = d >> 8 & 1;
      1|                    break;
       |
      5|                default:
       |            }
       |        }
       |    }
       |
       |    /*************************
       |     * PROCESSOR INFORMATION *
       |     *************************/
       |
       |    // ---- Basic information ----
       |    /// Processor vendor.
       |    public string Vendor;
       |    /// Processor brand string.
       |    public string ProcessorBrandString;
       |
       |    /// Maximum leaf supported by this processor.
       |    public int MaximumLeaf;
       |    /// Maximum extended leaf supported by this processor.
       |    public int MaximumExtendedLeaf;
       |
       |    /// Also known as Intel64 Architecture on Intel.
       |    public bool LongMode;
       |
       |    /// Number of physical cores.
       |    public ushort NumberOfCores;
       |    /// Number of logical cores.
       |    public ushort NumberOfThreads;
       |
       |    /// Processor family. ID and extended ID included.
       |    public ushort Family;
       |    /// Base Family ID
       |    public ubyte BaseFamily;
       |    /// Extended Family ID
       |    public ubyte ExtendedFamily;
       |    /// Processor model. ID and extended ID included.
       |    public ubyte Model;
       |    /// Base Model ID
       |    public ubyte BaseModel;
       |    /// Extended Model ID
       |    public ubyte ExtendedModel;
       |    /// Processor stepping.
       |    public ubyte Stepping;
       |    /// Processor type.
       |    public ubyte ProcessorType;
       |
       |    /// MMX Technology.
       |    public bool MMX;
       |    /// Streaming SIMD Extensions.
       |    public bool SSE;
       |    /// Streaming SIMD Extensions 2.
       |    public bool SSE2;
       |    /// Streaming SIMD Extensions 3.
       |    public bool SSE3;
       |    /// Supplemental Streaming SIMD Extensions 3 (SSSE3).
       |    public bool SSSE3;
       |    /// Streaming SIMD Extensions 4.1.
       |    public bool SSE41;
       |    /// Streaming SIMD Extensions 4.2.
       |    public bool SSE42;
       |    /// Streaming SIMD Extensions 4a. AMD-only.
       |    public bool SSE4a;
       |    /// AESNI instruction extensions.
       |    public bool AESNI;
       |    /// AVX instruction extensions.
       |    public bool AVX;
       |    /// AVX2 instruction extensions.
       |    public bool AVX2;
       |
       |    //TODO: Single instructions
       |
       |    // ---- 01h : Basic CPUID Information ----
       |    // -- EBX --
       |    /// Brand index. See Table 3-24. If 0, use normal BrandString.
       |    public ubyte BrandIndex;
       |    /// The CLFLUSH line size. Multiply by 8 to get its size in bytes.
       |    public ubyte CLFLUSHLineSize;
       |    /// Maximum number of addressable IDs for logical processors in this physical package.
       |    public ubyte MaximumNumberOfAddressableIDs;
       |    /// Initial APIC ID for this processor.
       |    public ubyte InitialAPICID;
       |    // -- ECX --
       |    /// PCLMULQDQ instruction.
       |    public bool PCLMULQDQ; // 1
       |    /// 64-bit DS Area (64-bit layout).
       |    public bool DTES64;
       |    /// MONITOR/MWAIT.
       |    public bool MONITOR;
       |    /// CPL Qualified Debug Store.
       |    public bool DS_CPL;
       |    /// Virtual Machine Extensions. AMD: SVM -- Secure Virtual Machine.
       |    public bool VMX;
       |    /// Safer Mode Extensions.
       |    public bool SMX;
       |    /// Enhanced Intel SpeedStep® technology.
       |    public bool EIST;
       |    /// Thermal Monitor 2.
       |    public bool TM2;
       |    /// L1 Context ID. If true, the L1 data cache mode can be set to either adaptive or shared mode. 
       |    public bool CNXT_ID;
       |    /// Indicates the processor supports IA32_DEBUG_INTERFACE MSR for silicon debug.
       |    public bool SDBG;
       |    /// FMA extensions using YMM state.
       |    public bool FMA;
       |    /// CMPXCHG16B instruction.
       |    public bool CMPXCHG16B;
       |    /// xTPR Update Control.
       |    public bool xTPR;
       |    /// Perfmon and Debug Capability.
       |    public bool PDCM;
       |    /// Process-context identifiers.
       |    public bool PCID;
       |    /// Direct Cache Access.
       |    public bool DCA;
       |    /// x2APIC feature (Intel programmable interrupt controller).
       |    public bool x2APIC;
       |    /// MOVBE instruction.
       |    public bool MOVBE;
       |    /// POPCNT instruction.
       |    public bool POPCNT;
       |    /// Indicates if the APIC timer supports one-shot operation using a TSC deadline value.
       |    public bool TSC_Deadline;
       |    /// Indicates the support of the XSAVE/XRSTOR extended states feature, XSETBV/XGETBV instructions, and XCR0.
       |    public bool XSAVE;
       |    /// Indicates if the OS has set CR4.OSXSAVE[18] to enable XSETBV/XGETBV instructions for XCR0 and XSAVE.
       |    public bool OSXSAVE;
       |    /// 16-bit floating-point conversion instructions.
       |    public bool F16C;
       |    /// RDRAND instruction.
       |    public bool RDRAND; // 30
       |    // -- EDX --
       |    /// Floating Point Unit On-Chip. The processor contains an x87 FPU.
       |    public bool FPU; // 0
       |    /// Virtual 8086 Mode Enhancements.
       |    public bool VME;
       |    /// Debugging Extensions.
       |    public bool DE;
       |    /// Page Size Extension.
       |    public bool PSE;
       |    /// Time Stamp Counter.
       |    public bool TSC;
       |    /// Model Specific Registers RDMSR and WRMSR Instructions. 
       |    public bool MSR;
       |    /// Physical Address Extension.
       |    public bool PAE;
       |    /// Machine Check Exception.
       |    public bool MCE;
       |    /// CMPXCHG8B Instruction.
       |    public bool CX8;
       |    /// Indicates if the processor contains an Advanced Programmable Interrupt Controller.
       |    public bool APIC;
       |    /// SYSENTER and SYSEXIT Instructions.
       |    public bool SEP;
       |    /// Memory Type Range Registers.
       |    public bool MTRR;
       |    /// Page Global Bit.
       |    public bool PGE;
       |    /// Machine Check Architecture.
       |    public bool MCA;
       |    /// Conditional Move Instructions.
       |    public bool CMOV;
       |    /// Page Attribute Table.
       |    public bool PAT;
       |    /// 36-Bit Page Size Extension.
       |    public bool PSE_36;
       |    /// Processor Serial Number. 
       |    public bool PSN;
       |    /// CLFLUSH Instruction.
       |    public bool CLFSH;
       |    /// Debug Store.
       |    public bool DS;
       |    /// Thermal Monitor and Software Controlled Clock Facilities.
       |    public bool APCI;
       |    /// FXSAVE and FXRSTOR Instructions.
       |    public bool FXSR;
       |    /// Self Snoop.
       |    public bool SS;
       |    /// Hyper-threading technology.
       |    public bool HTT;
       |    /// Thermal Monitor.
       |    public bool TM;
       |    /// Pending Break Enable.
       |    public bool PBE; // 31
       |
       |    // ---- 06h - Thermal and Power Management Leaf ----
       |    /// Turbo Boost Technology (Intel)
       |    public bool TurboBoost;
       |
       |
       |    // ---- 07h - Thermal and Power Management Leaf ----
       |    // -- EBX --
       |    /*
       |     * Note: BMI1, BMI2, and SMEP were introduced in 4th Generation Core-ix processors.
       |     */
       |    /// Bit manipulation group 1 instruction support.
       |    public bool BMI1; // 3
       |    /// Supervisor Mode Execution Protection.
       |    public bool SMEP; // 7
       |    /// Bit manipulation group 2 instruction support.
       |    public bool BMI2; // 8
       |
       |    // ---- 8000_0007 -  ----
       |    /// TSC Invariation support
       |    public bool TscInvariant; // 8
       |}
       |} // version else
ddcpuid.d is 80% covered
